<!DOCTYPE html>
<html lang="es">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Canvas WebGL Ajustable</title>
    <style>
      :root {
        color-scheme: light dark;
        font-family: "Inter", system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
        --accent: #0077ff;
        --panel-bg: rgba(18, 18, 18, 0.85);
        --panel-text: #f5f5f5;
        --panel-border: rgba(255, 255, 255, 0.08);
      }

      * {
        box-sizing: border-box;
      }

      body {
        margin: 0;
        min-height: 100vh;
        display: flex;
        flex-direction: column;
        background: radial-gradient(circle at top, #10131c, #05070c 55%);
        color: #f1f5f9;
      }

      header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 1.25rem clamp(1rem, 4vw, 2.5rem);
        background: rgba(10, 12, 18, 0.75);
        backdrop-filter: blur(14px);
        border-bottom: 1px solid rgba(255, 255, 255, 0.05);
      }

      header h1 {
        margin: 0;
        font-size: clamp(1.25rem, 3vw, 1.8rem);
        letter-spacing: 0.02em;
      }

      .controls {
        display: flex;
        align-items: center;
        gap: 0.75rem;
      }

      button {
        cursor: pointer;
        font-size: 1rem;
        border: 1px solid transparent;
        border-radius: 999px;
        padding: 0.6rem 1.3rem;
        background: var(--accent);
        color: #fff;
        font-weight: 600;
        transition: transform 0.2s ease, box-shadow 0.2s ease;
      }

      button:hover,
      button:focus-visible {
        outline: none;
        transform: translateY(-1px);
        box-shadow: 0 10px 25px rgba(0, 119, 255, 0.35);
      }

      main {
        flex: 1;
        display: flex;
        flex-direction: column;
        align-items: center;
        padding: clamp(1.5rem, 4vw, 3rem);
        gap: 1.5rem;
      }

      #glCanvas {
        width: 100%;
        max-width: min(960px, 90vw);
        aspect-ratio: 16 / 10;
        border-radius: 1.25rem;
        border: 1px solid rgba(255, 255, 255, 0.07);
        background: #020205;
        box-shadow: 0 18px 35px rgba(3, 7, 18, 0.6);
      }

      .info {
        max-width: 960px;
        text-align: center;
        line-height: 1.6;
        color: rgba(226, 232, 240, 0.9);
        font-size: clamp(1rem, 2.5vw, 1.1rem);
      }

      .settings-panel {
        position: fixed;
        inset: 0;
        background: rgba(4, 6, 12, 0.55);
        display: grid;
        place-items: center;
        opacity: 0;
        pointer-events: none;
        transition: opacity 0.3s ease;
        padding: 1rem;
      }

      .settings-panel.open {
        opacity: 1;
        pointer-events: all;
      }

      .settings-card {
        background: var(--panel-bg);
        color: var(--panel-text);
        border-radius: 1.25rem;
        border: 1px solid var(--panel-border);
        width: min(360px, 100%);
        padding: 1.75rem;
        box-shadow: 0 20px 45px rgba(0, 0, 0, 0.45);
        display: flex;
        flex-direction: column;
        gap: 1.25rem;
      }

      .settings-card h2 {
        margin: 0;
        font-size: 1.35rem;
        font-weight: 700;
      }

      .settings-card form {
        display: flex;
        flex-direction: column;
        gap: 1.25rem;
      }

      label {
        display: flex;
        flex-direction: column;
        gap: 0.35rem;
        font-weight: 600;
        letter-spacing: 0.01em;
      }

      input[type="number"] {
        padding: 0.65rem 0.85rem;
        border-radius: 0.75rem;
        border: 1px solid rgba(255, 255, 255, 0.2);
        background: rgba(12, 15, 23, 0.8);
        color: inherit;
        font-size: 1rem;
      }

      input[type="number"]:focus-visible {
        outline: 2px solid var(--accent);
        border-color: transparent;
      }

      input[type="range"] {
        -webkit-appearance: none;
        appearance: none;
        width: 100%;
        height: 0.4rem;
        border-radius: 999px;
        background: rgba(255, 255, 255, 0.25);
        outline: none;
        accent-color: var(--accent);
      }

      input[type="range"]::-webkit-slider-thumb {
        -webkit-appearance: none;
        appearance: none;
        width: 18px;
        height: 18px;
        border-radius: 50%;
        background: var(--accent);
        cursor: pointer;
        box-shadow: 0 4px 12px rgba(0, 119, 255, 0.4);
      }

      input[type="range"]::-moz-range-thumb {
        width: 18px;
        height: 18px;
        border-radius: 50%;
        background: var(--accent);
        cursor: pointer;
        box-shadow: 0 4px 12px rgba(0, 119, 255, 0.4);
      }

      select {
        padding: 0.65rem 0.85rem;
        border-radius: 0.75rem;
        border: 1px solid rgba(255, 255, 255, 0.2);
        background: rgba(12, 15, 23, 0.8);
        color: inherit;
        font-size: 1rem;
      }

      select:focus-visible {
        outline: 2px solid var(--accent);
        border-color: transparent;
      }

      fieldset {
        border: 1px solid var(--panel-border);
        border-radius: 1rem;
        padding: 1.1rem;
        display: flex;
        flex-direction: column;
        gap: 1rem;
      }

      fieldset legend {
        padding: 0 0.5rem;
        font-weight: 700;
        letter-spacing: 0.01em;
      }

      .dimension-grid {
        display: grid;
        grid-template-columns: repeat(2, minmax(0, 1fr));
        gap: 1rem;
      }

      .range-group {
        display: flex;
        flex-direction: column;
        gap: 0.35rem;
      }

      .range-label {
        display: flex;
        justify-content: space-between;
        align-items: baseline;
        font-weight: 600;
        font-size: 0.95rem;
      }

      .value-badge {
        font-size: 0.85rem;
        background: rgba(15, 23, 42, 0.65);
        border: 1px solid rgba(255, 255, 255, 0.18);
        border-radius: 999px;
        padding: 0.15rem 0.6rem;
      }

      .actions {
        display: flex;
        justify-content: flex-end;
        gap: 0.75rem;
      }

      .ghost {
        background: transparent;
        border: 1px solid rgba(255, 255, 255, 0.3);
        color: inherit;
      }

      .inline-actions {
        display: flex;
        justify-content: space-between;
        gap: 0.75rem;
        flex-wrap: wrap;
      }

      footer {
        text-align: center;
        padding: 1.5rem;
        font-size: 0.95rem;
        color: rgba(148, 163, 184, 0.85);
      }

      @media (max-width: 540px) {
        header {
          flex-direction: column;
          gap: 0.75rem;
          text-align: center;
        }

        .controls {
          width: 100%;
          justify-content: center;
        }

        .settings-card {
          padding: 1.4rem;
        }
      }
    </style>
  </head>
  <body>
    <header>
      <h1>Canvas WebGL Interactivo</h1>
      <div class="controls">
        <button id="settingsToggle" type="button" aria-haspopup="dialog" aria-controls="settingsPanel">
          Ajustes de lienzo
        </button>
      </div>
    </header>
    <main>
      <canvas id="glCanvas" role="img" aria-label="Mapa procedural generado con ruido Perlin"></canvas>
      <p class="info">
        Explora un mapa procedural generado con múltiples filtros de ruido de Perlin que puedes ajustar en tiempo real.
        Configura las dimensiones del lienzo y mezcla distintas capas de ruido para descubrir paisajes únicos al instante.
      </p>
    </main>
    <footer>
      Hecho con WebGL para demostraciones en GitHub Pages.
    </footer>

    <div
      class="settings-panel"
      id="settingsPanel"
      role="dialog"
      aria-modal="true"
      aria-labelledby="settingsTitle"
    >
      <div class="settings-card">
        <h2 id="settingsTitle">Dimensiones del lienzo</h2>
        <form id="settingsForm">
          <div class="dimension-grid">
            <label>
              Ancho (px)
              <input id="widthInput" type="number" min="200" max="2000" step="10" required value="640" />
            </label>
            <label>
              Alto (px)
              <input id="heightInput" type="number" min="200" max="2000" step="10" required value="400" />
            </label>
          </div>

          <fieldset>
            <legend>Ruido procedural</legend>
            <div class="range-group">
              <div class="range-label">
                Escala
                <span class="value-badge" id="scaleValue">3.0</span>
              </div>
              <input id="scaleInput" type="range" min="0.5" max="8" step="0.1" value="3" />
            </div>

            <div class="range-group">
              <div class="range-label">
                Octavas
                <span class="value-badge" id="octavesValue">5</span>
              </div>
              <input id="octavesInput" type="range" min="1" max="8" step="1" value="5" />
            </div>

            <div class="range-group">
              <div class="range-label">
                Persistencia
                <span class="value-badge" id="persistenceValue">0.5</span>
              </div>
              <input id="persistenceInput" type="range" min="0.1" max="1" step="0.05" value="0.5" />
            </div>

            <div class="range-group">
              <div class="range-label">
                Lacunaridad
                <span class="value-badge" id="lacunarityValue">2.0</span>
              </div>
              <input id="lacunarityInput" type="range" min="1.2" max="3.5" step="0.1" value="2" />
            </div>

            <label>
              Filtro de ruido
              <select id="filterSelect">
                <option value="0">fBm clásico</option>
                <option value="1">Crestas (ridged)</option>
                <option value="2">Turbulencia</option>
              </select>
            </label>

            <label>
              Semilla
              <input id="seedInput" type="number" min="0" max="9999" step="1" value="42" />
            </label>

            <div class="inline-actions">
              <span aria-live="polite">Ajustes aplicados en tiempo real.</span>
              <button class="ghost" type="button" id="randomizeSeed">Aleatorizar mapa</button>
            </div>
          </fieldset>

          <div class="actions">
            <button class="ghost" type="button" id="cancelSettings">Cerrar</button>
            <button type="submit">Aplicar tamaño</button>
          </div>
        </form>
      </div>
    </div>

    <script>
      const canvas = document.getElementById("glCanvas");
      const gl = canvas.getContext("webgl", { antialias: true, powerPreference: "high-performance" });

      if (!gl) {
        canvas.insertAdjacentHTML(
          "beforebegin",
          '<p role="alert">Tu navegador no soporta WebGL. Prueba con una versión más reciente.</p>'
        );
        throw new Error("WebGL no soportado");
      }

      const vertexShaderSource = `
        attribute vec2 a_position;
        varying vec2 v_uv;

        void main() {
          v_uv = (a_position + 1.0) * 0.5;
          gl_Position = vec4(a_position, 0.0, 1.0);
        }
      `;

      const fragmentShaderSource = `
        precision highp float;
        varying vec2 v_uv;
        uniform vec2 u_resolution;
        uniform float u_scale;
        uniform float u_persistence;
        uniform float u_lacunarity;
        uniform int u_octaves;
        uniform float u_seed;
        uniform int u_filterMode;

        vec2 hash2(vec2 p) {
          p = vec2(
            dot(p, vec2(127.1, 311.7)),
            dot(p, vec2(269.5, 183.3))
          );
          return -1.0 + 2.0 * fract(sin(p) * 43758.5453123);
        }

        float perlin(vec2 p) {
          vec2 i = floor(p);
          vec2 f = fract(p);

          vec2 u = f * f * (3.0 - 2.0 * f);

          float n00 = dot(hash2(i + vec2(0.0, 0.0)), f - vec2(0.0, 0.0));
          float n10 = dot(hash2(i + vec2(1.0, 0.0)), f - vec2(1.0, 0.0));
          float n01 = dot(hash2(i + vec2(0.0, 1.0)), f - vec2(0.0, 1.0));
          float n11 = dot(hash2(i + vec2(1.0, 1.0)), f - vec2(1.0, 1.0));

          float nx0 = mix(n00, n10, u.x);
          float nx1 = mix(n01, n11, u.x);
          return mix(nx0, nx1, u.y);
        }

        float filteredNoise(float value) {
          if (u_filterMode == 1) {
            return (1.0 - abs(value)) * 2.0 - 1.0;
          } else if (u_filterMode == 2) {
            return abs(value) * 2.0 - 1.0;
          }
          return value;
        }

        float fbm(vec2 p) {
          const int MAX_OCTAVES = 8;
          float amplitude = 0.5;
          float frequency = 1.0;
          float sum = 0.0;
          float total = 0.0;
          vec2 seedOffset = vec2(
            cos(u_seed * 12.9898),
            sin(u_seed * 78.233)
          ) * 100.0;

          for (int i = 0; i < MAX_OCTAVES; i++) {
            if (i >= u_octaves) {
              break;
            }
            float noiseValue = perlin(p * frequency + seedOffset);
            noiseValue = filteredNoise(noiseValue);
            sum += noiseValue * amplitude;
            total += amplitude;
            amplitude *= u_persistence;
            frequency *= u_lacunarity;
          }

          if (total > 0.0) {
            sum /= total;
          }
          return sum;
        }

        vec3 palette(float h) {
          vec3 waterDeep = vec3(0.066, 0.129, 0.329);
          vec3 waterShallow = vec3(0.137, 0.341, 0.533);
          vec3 beach = vec3(0.753, 0.686, 0.498);
          vec3 grass = vec3(0.278, 0.486, 0.282);
          vec3 forest = vec3(0.203, 0.337, 0.231);
          vec3 rock = vec3(0.388, 0.376, 0.365);
          vec3 snow = vec3(0.894, 0.909, 0.925);

          if (h < 0.32) {
            return mix(waterDeep, waterShallow, smoothstep(0.0, 0.32, h));
          } else if (h < 0.38) {
            return mix(waterShallow, beach, smoothstep(0.32, 0.38, h));
          } else if (h < 0.6) {
            return mix(beach, grass, smoothstep(0.38, 0.6, h));
          } else if (h < 0.72) {
            return mix(grass, forest, smoothstep(0.6, 0.72, h));
          } else if (h < 0.88) {
            return mix(forest, rock, smoothstep(0.72, 0.88, h));
          }
          return mix(rock, snow, smoothstep(0.88, 1.0, h));
        }

        void main() {
          vec2 aspect = vec2(u_resolution.x / u_resolution.y, 1.0);
          vec2 uv = (v_uv - 0.5) * aspect * u_scale;

          float height = fbm(uv);
          height = clamp(height * 0.5 + 0.5, 0.0, 1.0);

          float derivativeStep = u_scale / max(u_resolution.x, u_resolution.y);
          float heightX = fbm(uv + vec2(derivativeStep, 0.0));
          float heightY = fbm(uv + vec2(0.0, derivativeStep));
          heightX = clamp(heightX * 0.5 + 0.5, 0.0, 1.0);
          heightY = clamp(heightY * 0.5 + 0.5, 0.0, 1.0);

          vec3 color = palette(height);

          float slope = clamp((height - 0.5 * (heightX + heightY)) * 6.0 + 0.5, 0.0, 1.0);
          vec3 light = vec3(1.15, 1.1, 1.05);
          vec3 shade = vec3(0.55, 0.58, 0.62);

          color *= mix(shade, light, slope);

          gl_FragColor = vec4(color, 1.0);
        }
      `;

      function createShader(type, source) {
        const shader = gl.createShader(type);
        gl.shaderSource(shader, source);
        gl.compileShader(shader);
        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
          const info = gl.getShaderInfoLog(shader);
          gl.deleteShader(shader);
          throw new Error(`Error compilando shader: ${info}`);
        }
        return shader;
      }

      function createProgram(vertexSource, fragmentSource) {
        const vertexShader = createShader(gl.VERTEX_SHADER, vertexSource);
        const fragmentShader = createShader(gl.FRAGMENT_SHADER, fragmentSource);
        const program = gl.createProgram();
        gl.attachShader(program, vertexShader);
        gl.attachShader(program, fragmentShader);
        gl.linkProgram(program);
        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
          const info = gl.getProgramInfoLog(program);
          gl.deleteProgram(program);
          throw new Error(`Error enlazando programa: ${info}`);
        }
        return program;
      }

      const program = createProgram(vertexShaderSource, fragmentShaderSource);
      gl.useProgram(program);

      const positionBuffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
      const positions = new Float32Array([
        -1, -1,
        1, -1,
        -1, 1,
        -1, 1,
        1, -1,
        1, 1,
      ]);
      gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);

      const aPositionLocation = gl.getAttribLocation(program, "a_position");
      gl.enableVertexAttribArray(aPositionLocation);
      gl.vertexAttribPointer(aPositionLocation, 2, gl.FLOAT, false, 0, 0);

      const uniformLocations = {
        resolution: gl.getUniformLocation(program, "u_resolution"),
        scale: gl.getUniformLocation(program, "u_scale"),
        persistence: gl.getUniformLocation(program, "u_persistence"),
        lacunarity: gl.getUniformLocation(program, "u_lacunarity"),
        octaves: gl.getUniformLocation(program, "u_octaves"),
        seed: gl.getUniformLocation(program, "u_seed"),
        filterMode: gl.getUniformLocation(program, "u_filterMode"),
      };

      const DEFAULT_SIZE = { width: 640, height: 400 };
      const DEFAULT_NOISE = {
        scale: 3,
        octaves: 5,
        persistence: 0.5,
        lacunarity: 2,
        seed: 42,
        filterMode: 0,
      };

      const noiseState = { ...DEFAULT_NOISE };

      function updateNoiseUniforms() {
        gl.uniform1f(uniformLocations.scale, noiseState.scale);
        gl.uniform1f(uniformLocations.persistence, noiseState.persistence);
        gl.uniform1f(uniformLocations.lacunarity, noiseState.lacunarity);
        gl.uniform1i(uniformLocations.octaves, noiseState.octaves);
        gl.uniform1f(uniformLocations.seed, noiseState.seed);
        gl.uniform1i(uniformLocations.filterMode, noiseState.filterMode);
      }

      function setCanvasSize(width, height) {
        const clampedWidth = Math.min(Math.max(width, 200), 2000);
        const clampedHeight = Math.min(Math.max(height, 200), 2000);
        const deviceRatio = window.devicePixelRatio || 1;

        canvas.style.width = `${clampedWidth}px`;
        canvas.style.height = `${clampedHeight}px`;
        canvas.width = Math.round(clampedWidth * deviceRatio);
        canvas.height = Math.round(clampedHeight * deviceRatio);
        gl.viewport(0, 0, canvas.width, canvas.height);

        gl.uniform2f(uniformLocations.resolution, canvas.width, canvas.height);
      }

      function render() {
        gl.clearColor(0.0, 0.0, 0.0, 1.0);
        gl.clear(gl.COLOR_BUFFER_BIT);
        gl.drawArrays(gl.TRIANGLES, 0, 6);

        requestAnimationFrame(render);
      }

      const settingsToggle = document.getElementById("settingsToggle");
      const settingsPanel = document.getElementById("settingsPanel");
      const cancelButton = document.getElementById("cancelSettings");
      const form = document.getElementById("settingsForm");
      const widthInput = document.getElementById("widthInput");
      const heightInput = document.getElementById("heightInput");
      const scaleInput = document.getElementById("scaleInput");
      const octavesInput = document.getElementById("octavesInput");
      const persistenceInput = document.getElementById("persistenceInput");
      const lacunarityInput = document.getElementById("lacunarityInput");
      const filterSelect = document.getElementById("filterSelect");
      const seedInput = document.getElementById("seedInput");
      const randomizeSeed = document.getElementById("randomizeSeed");

      const scaleValue = document.getElementById("scaleValue");
      const octavesValue = document.getElementById("octavesValue");
      const persistenceValue = document.getElementById("persistenceValue");
      const lacunarityValue = document.getElementById("lacunarityValue");

      function refreshNoiseInputs() {
        scaleInput.value = noiseState.scale;
        scaleValue.textContent = noiseState.scale.toFixed(1);
        octavesInput.value = noiseState.octaves;
        octavesValue.textContent = String(noiseState.octaves);
        persistenceInput.value = noiseState.persistence;
        persistenceValue.textContent = noiseState.persistence.toFixed(2);
        lacunarityInput.value = noiseState.lacunarity;
        lacunarityValue.textContent = noiseState.lacunarity.toFixed(2);
        filterSelect.value = String(noiseState.filterMode);
        seedInput.value = Math.round(noiseState.seed);
      }

      function openSettings() {
        widthInput.value = Math.round(parseFloat(canvas.style.width) || DEFAULT_SIZE.width);
        heightInput.value = Math.round(parseFloat(canvas.style.height) || DEFAULT_SIZE.height);
        refreshNoiseInputs();
        settingsPanel.classList.add("open");
        settingsToggle.setAttribute("aria-expanded", "true");
        widthInput.focus();
      }

      function closeSettings() {
        settingsPanel.classList.remove("open");
        settingsToggle.setAttribute("aria-expanded", "false");
        settingsToggle.focus();
      }

      settingsToggle.addEventListener("click", () => {
        if (settingsPanel.classList.contains("open")) {
          closeSettings();
        } else {
          openSettings();
        }
      });

      cancelButton.addEventListener("click", () => {
        closeSettings();
      });

      settingsPanel.addEventListener("click", (event) => {
        if (event.target === settingsPanel) {
          closeSettings();
        }
      });

      scaleInput.addEventListener("input", () => {
        noiseState.scale = Number(scaleInput.value);
        scaleValue.textContent = noiseState.scale.toFixed(1);
        updateNoiseUniforms();
      });

      octavesInput.addEventListener("input", () => {
        noiseState.octaves = Math.round(Number(octavesInput.value));
        octavesValue.textContent = String(noiseState.octaves);
        updateNoiseUniforms();
      });

      persistenceInput.addEventListener("input", () => {
        noiseState.persistence = Number(persistenceInput.value);
        persistenceValue.textContent = noiseState.persistence.toFixed(2);
        updateNoiseUniforms();
      });

      lacunarityInput.addEventListener("input", () => {
        noiseState.lacunarity = Number(lacunarityInput.value);
        lacunarityValue.textContent = noiseState.lacunarity.toFixed(2);
        updateNoiseUniforms();
      });

      filterSelect.addEventListener("change", () => {
        noiseState.filterMode = Number(filterSelect.value);
        updateNoiseUniforms();
      });

      seedInput.addEventListener("input", () => {
        noiseState.seed = Number(seedInput.value);
        updateNoiseUniforms();
      });

      randomizeSeed.addEventListener("click", () => {
        const randomSeed = Math.floor(Math.random() * 10000);
        noiseState.seed = randomSeed;
        seedInput.value = randomSeed;
        updateNoiseUniforms();
      });

      form.addEventListener("submit", (event) => {
        event.preventDefault();
        const newWidth = Number(widthInput.value);
        const newHeight = Number(heightInput.value);
        setCanvasSize(newWidth, newHeight);
        closeSettings();
      });

      window.addEventListener("resize", () => {
        const currentWidth = parseFloat(canvas.style.width) || DEFAULT_SIZE.width;
        const currentHeight = parseFloat(canvas.style.height) || DEFAULT_SIZE.height;
        setCanvasSize(currentWidth, currentHeight);
      });

      setCanvasSize(DEFAULT_SIZE.width, DEFAULT_SIZE.height);
      updateNoiseUniforms();
      refreshNoiseInputs();
      requestAnimationFrame(render);
    </script>
  </body>
</html>
